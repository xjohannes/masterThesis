 \documentclass[english]{ifimaster}
\usepackage[utf8]{inputenc}
\usepackage{babel,textcomp,csquotes,varioref,graphicx}% ifikompendiumforside Remember to ads
\usepackage[T1]{fontenc}
\usepackage[hyphens]{url} % deler lange url-er

% biblatex-pakka med opsjoner
\usepackage[backend=biber, style=numeric-comp,%
defernumbers=true, style=authoryear, backref,sortcites]{biblatex}

\usepackage[normalem]{ulem} %enables strike through
% To enable code with correct indentation for JavaScript
\usepackage{listings}
\renewcommand*{\lstlistlistingname}{List of Code}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}
\usepackage{graphicx}
\graphicspath{ {images/} }
% må opplyse om bib-filen
% ved flere bib-filer gjentas kommandoen
\addbibresource{bibliography.bib}

% denne kommandoen er for reftex som ikke forstår BibLaTeX
%\bibliography{referanser}

% noen mulige lokale biblatex tilpasninger
%\DefineBibliographyStrings{norsk}{%
%   urlseen={Sett: },
%   bibliography = {Bibliografi},
%   references = {Referanser},
%   editor = {redaktør},
%   translator={oversetter},
   %page={side},
   %pages={sidene},
%   and={og}
%}
%\reg{fig:picture8}
% /begin{figure}[htbp]
%\centering
%\includegraphics[scale=0.6]{imgName.png}
%\caption{Bla bla}
%\label{fig:picture8}
%\end{figure}

\DeclareFieldFormat{url}{\url{#1}} % fjerner hardkodet "URL: " foran url

\DeclareUrlCommand\url{\def\UrlLeft{\newline}\def\UrlRight{\newline}%
\urlstyle{sf}} % setter inn passende linjeskift

% biblatex anbefaler at hyperref blir lastet inn etter biblatex
\usepackage{hyperref}

\title{Applying client side state management on server rendered web pages}
%\subtitle{} 
% Sett inn ditt eget navn her:
\author{Johannes Akse}
\date{2016}

\begin{document}
%\ififorside
\maketitle{}
\pagenumbering{roman}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Abstract %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Abstract}
As might be demanded of post modern information technology the web client can mash together information from several different sources and by that create information and express novel ideas to the users and the world. The HyperBrowsers new state functionality utilizes the web client letting scientists share their scientific questions and hypothesises which not only facilitate reproducibility but also promote augmenting the human intellect.

Applying state management, however simple that sound ... 

\tableofcontents
\nocite{*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Preface %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Preface}
"Personal" motivation for writing the thesis, the changing of focus from wizard to state (basic/advanced) and lastly adding history functionality. Write the main portion of the thesis as if history management was a specification all the way or integrating the addition of this in the introduction?

These features, even though not part of the original requirement specifications for this master thesis, has after implementation been received with some expectations from in-house users of the system. 

No expert supervisor on javaScript and main supervisor on paternity leave I have been quite alone when making design decisions. 

Open the eyes of the university for JavaScript.
\chapter*{Notes. Must be deleted upon due date}

 Tell, don't ask https://pragprog.com/articles/tell-dont-ask

 Does the getting of the state of the mode object to set the isBasic element in the gsuite tools break with the principle of Telling, not asking?

 Are the JavaScript nature of functions, ie apply, call and bind, ways of breaking with good OOP practices? Does cohesion suffer when passing functionality around without an object controlling it?

\section{Discarded}

\subsection{Intro}
The intention of the web to augment the human brain, From Doug Engelbart to Sir Tim Bernes-Lee, has been the motivation behind many a web project(Howard Rheingold). This is also the grounds on which the Hyperbrowsers was born, to help researchers do better research on genomic data. The HyperBrowser provide tools to aid researchers in defining advanced statistical hypothesises on genomic data. The galaxy platform, on which the Hyperbrowser is built, facilitates sharing results, "the state app", the application under scrutiny, gives the opportunity to share research questions. It also enables information hiding. Users not familiar with the user interface or with making complex statistical hypothesis based on genome data may be overloaded with the amount of choices and of the information presented by the Hyperbrowser. The hiding and revealing of information in a basic or advanced mode is the second specification the state app has brought to the Hyperbrowser.

\subsection{Motivation}
As the Internet has matured, we, the users of the World Wide Web, have started to expect certain behavior from a web page\parencite[p.85]{mikowski}. Whether the web site is about displaying dynamically rendered news articles or, as is the case of "The Genomic HyperBrowser", doing statistical analyzes on a genome, the users expect to be able to use the built in actions most browsers provide. Going back and forth using the navigation arrows on the top left side of the page or bookmarking a page for later reference or even sending a link to a friend or colleague is build in functionality every site should strive to provide for its users.

Because of the inner workings of most browsers the back and forward functionality works as expected for the Hyperbrowser, but saving the state in a bookmark for later retrieval or for the purpose of sending the state to a co-worker or other scientist has however not been possible and is one of the main focus of this thesis.

The other main focus has been that of concealing information...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Introduction %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\listoffigures
\part{Introduction}
\chapter{Introduction}
\pagenumbering{arabic}
\section{Background}
% Get the reader up to speed on terminology and the field.
\section{Rationale (Motivation)}
%Why there is a need for a product to do what i propose to do

%Expectations to be able to save state, but no explicit recipes. There exists a lot of frameworks but no obvious how and which ones that will give the best help. Many different solutions, store in cash, local storage, location.hash but which is better?

% There is insecurities, so its important that someone explores the solutions. But I don't explore the solutions?

\section{Purpose}
Google search supports a basic and advanced mode. From neuro science\parencite{maldjian2003automated} tools to google search provides basic.

% Explore state, the meaning of state. This is what I have wanted to investigate. How state can be in a situation where it is both on the client and on the server.

%State is important. How to handle state client side when generated server side? Where is the state supposed to reside? Explore this dilemma.

\section{Goals}
%(Entice the reader, what are they about to spend time reading, why would they?)
My first goal is to show why implementing a simple feature like a button changing between basic and advanced mode, even though sounding like an easy task, is far from trivial when done on an already existing web page. 

Secondly I show that the underlying structure needed to build such a seemingly simple feature facilitates faster and easier development of other state dependent functionality. This structure is provided by following certain principles for good coding practices, such as encapsulation and loose coupling which provide (reliability, maintainability, usability)

The programatic contribution to the thesis has two parts:
\begin{itemize}
  \item Providing a generic basic /advanced button to accommodate state changes for all state dependent functionality.
  \item Handling state within tools. 
\end{itemize}

\section{Overview}
\paragraph{Background}


The next few sections will discuss different aspects of the web client, the DOM and give a general overview of certain aspects of JavaScript necessary to follow the main part of this thesis, the discussion. 

Lastly I give the reader a short introduction to design patterns. I do this to introduce an ongoing discussion of which I will join later.

\paragraph{Methodology}
How did I go about exploring the questions at hand?

%The pre-project with Angularjs. State was explored as every page was a different state as in a state machine. The history object acts as a state machine.

This section will concern explanations on behavior driven development and module based implementation provided by browserify. Why and how has behavior driven development made the implementation faster and easier.
\paragraph{Empirical - Development}
The hyperbrowser is an interesting case.
I will start this section with an explanation of what "the Genomic Hyperbrowser" is and discuss some of its reported problems concerning usability. The G-suite project addresses some of these problems but do so server side. 

The State application has been integrated with the G-suite to address these problems on the client side. The aspects of the G-suite that relate to usability will be laid out before I give a short explanations on state, what it is and why it matters. 
In this section I will discuss the important details of the implementation of the program under scrutiny. 

\paragraph{Discussion}
As a means to guide the discussion in the wanted direction I promote three overarching assertions (sub theses). These assertions will be followed by more fine grained statements supporting or contradicting the main assertions. 

The three main assertions are:
\begin{enumerate}
  \item A simple task like a basic advanced button applied client side on top of an existing server rendered web page is not trivial.
  \item Structuring complex code using an unstructured, dynamic scripting language like java script can be challenging.
  \item With structured code, new functionality comes easier. 
\end{enumerate}

\section{Limitations /boundaries of the thesis (avgrensning)}

\section{Development in a real time setting}


\section{Challenges (Justifications)}
Short introduction to the some of the main arguments of the discussion: 

How easy the problem could have been if I was to make the application from scratch, tweaking specifications as I met problems.

\sout{The challenges of working with a web client, in different browsers, different standards HTML5(pushState), the server that could not be set up for pushState.}

\sout{Working with frames, communication over boundaries.}

\sout{Challenges of working with an unstructured programming language like JavaScript compared to Java.}




\section{Problem statement}
\sout{How to apply state management for predefined server rendered pages in a web browser}

\section{Terminology}

\subsection{Acronyms}
URI - Uniform Recourse Identifier.
URL - Uniform Recourse Locator. 
\#  - The octothorp. Within a URI als called the fragment identifier, the hash sign and the anchor. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Background %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Background}
\section{A real world use case}
\subsection{The Genomic HyperBrowser}
\subsection{the G-suite - A need to simplify the UI}

\section{State management}
Why is client side state management an interesting issue. What led up to the problems we have to day. Copy past from discussion? The world wide web as a tool to augment the human intellect.
\subsection{What is state?}
\label{sec:state}
\subsection{Why is state important?}
 [Bernstein, 1991]. He argues that
the value of hypertext lies in its ability to create
serendipitous connections between unexpected
ideas.

The use of tabs as a readily available history list

Cockburn suggests a temporal back (ABCBAH) to avoid pruning of the navigation stack after loading a new page after navigating back thereby loosing the previous page.

What implementation consequences has the back schemes i.e. going back one step or to the last "page"?

Reluctance to use back can stem from form submission and that state is usually lost when going back.\parencite{obendorf}

We compared
the backtracking usage of the top third ‘form submitters’ of
our participants with the remaining participants. The regular
users of Web forms pressed the back button less frequently
(9.2%) than the remaining participants (16.2%), a difference
that is marginally significant (t=2.715, p=0.012). This
result characterizes a major change of the Web: the move
from a hypertext information system with primarily static
documents into a combination of common information
source and service-oriented interactive sites. The latter are
more comparable to applications than to hypertext systems.
Whereas hypertext navigation involves orienteering behavior
with frequent backtracking, interactive applications are
mainly used for completing certain tasks that consist of
different workflow steps.\parencite{obendorf}

Further, the back button is often unsupported by Web applications.

 Furthermore, such pages cannot
be bookmarked at all; they are volatile and no browser
history mechanism allows for returning to them
\parencite{obendorf}

undo vs revisit - back vs tab(window)

The DOM as a serve all utility for storing both application and data information.
" The browser DOM must function as a
“catch-all” container for application script, presentation
elements, and non-visual application data."\parencite{castro}
Baisc advanced spreadsheet\parencite{jafry}
\subsection{The statelessness of REST}

\section{The web client}
"The web browser is perhaps the most widely used software application in history. It has evolved significantly over the past twenty years; today, web browsers run on diverse types of hardware, from cell phones and tablet PCs to desktop computers"\parencite[p. 2]{gross}. We even have iWatches and Google glasses. The web client is no longer just a reader of static information browsing interlinked web pages. Now it is better described as a simplified OS\parencite[p.310]{flanagan}. The browsers provide ways to organize web documents and web applications in folder structures. As is the case for the current state app, it allows for organization of statistical analysis questions and hypothesises. Web browsers also allows for running multiple discrete applications much like an OS. The state app consists of two distinct applications, one that handles tool state and one that synchronizes mode between frames. Thirdly web browsers define low-level API's for activities such as networking and saving data. 

The Genomic HyperBrowser use some of these new technologies. It does rely on jQuerys Ajax suite to do some of the communication with the server. It also relies on one of the new HTML5 specifications, the localStorage API, which it has entrusted to a third party library, JStorage. 

While utilizing new web standards on some parts of the page the Hyperbrowser also rely heavily on the somewhat discouraged technique of using iframes for separating content on a page. Using frames is the first mistake web designers do according to usability guru Jacob Nilsen. "It brakes the fundamental user model of the web page. All of a sudden, you cannot bookmark the current page and return to it \parencite{nielsen1997user}.

The usage of iframes stems from the fact that the HyperBrowser is an extension of an other open source, web-based platform for data intensive biomedical research, namely the Galaxy platform and is by that dependent on how the Galaxy project was originally implemented. The consequences of having to deal with iframes for the state app will be discussed later in this chapter.

\subsection{The DOM}
For a program to manage state within a browser context it needs some way to interact with the HTML elements displayed on the page. The standard programming language for all modern browsers, JavaScript, provides such an entry point. When the server returns the requested page the browser creates a plain JavaScript object, called the document object, and uses it as the root of a tree like structure. It then parses the received HTML. For every HTML element it creates a responding JavaScript object and adds it to the document tree. This tree is often referred to as the DOM. All of these JavaScript objects have fields that correspond to all the HTML element attributes. The elements most interesting to the discussions of this thesis are the iframe element and the form element. These have such a central place in the development that they deserve a whole section each.


\section{JavaScript}
\begin{quotation}
\noindent JavaScript is ”[…] clearly a grossly substandard language by modern
standards and thus can be legitimately described as a toy language.” —
\parencite{arno}
\end{quotation}

Even though some people still have problems recognizing JavaScript as more than a toy programing language JavaScript has had a rapid evolution the last 10 years. The emergence of  big JavaScript libraries and frameworks like Backbonejs and Angularjs can be seen as a direct consequence of what has been coined the second browser war\parencite{Yule2013}. Especially after Google launched their Chrome browser in 2008 and the JavaScript runtime Nodejs was build on top of chromes V8 engine, the speed of interpreting JavaScript has increased enormously. Other JavaScript engines now uses dynamic compilation, also called "Just in time" technology and the V8 compiles directly to byte code which make them even faster\parencite{anand}. JavaScript is also the standard programing language of the "World Wide Web"\parencite[p. 1]{flanagan} and is thereby one of the most used programing languages.

\subsection{The JavaScript prototype chain}

\section{Design principles}
\subsection{Open/closed principle}
Robert Martin (SOLID);
\subsection {Loose coupling}
Martin Fowler

\subsection{Classical design patterns}
Classical design patterns carry a double meaning. On the one hand "classical" design patterns refer to well established and thoroughly tested coding practices\parencite[p. 12]{gamma}. On the other hand "classical" design patterns refer to object-oriented programming where classes act as a template for object production\parencite[p. 115]{stefanov}. The "classical" and highly influential book "Design patterns: Elements of Reusable Object-Oriented Software" suggests as a starting point twenty three named object oriented design patterns. The "main goals of the book was to capture and record experience on design in a form that people can use effectively"\parencite[p. 12]{gamma}. Good design patterns with thereto thoughtful and descriptive names can both establish a vocabulary that can ease communication between experienced programmers, assist in faster comprehension of object oriented programming principles and function as cognitive aids for junior programmers and programming students.


\subsection{The MVC controversy}
How to implement the MVC pattern with JavaScipt. Different angles seen through the eyes of JavaScript frameworks such as Angularjs and backbone. This is done because the role of the model and the controller has been difficult to decide when developing the state app.

\subsubsection{The observer pattern}
The intent of the Observer pattern is to “define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically”\parencite[p. 9]{gamma}. It is often described as a publish-subscriber relationship where the observers subscribe to events and the observable "publishes" events to the subscribers letting them know there is a new "publication" ready. The "publication" can for instance be a state change in the publisher or other related code. Following the publisher-subscriber metaphor a little further; when a newspaper is ready for publication there has usually been two ways for news readers to obtain an exemplar of the paper, one by going to a news stand buying it there, the other to subscribe and thereby get it delivered to the front door\parencite[p. 171-174]{stefanov}.

\section{JavaScript meets classical design patterns}
As goes for all design patterns, every implementation needs to tweak the original to fit the problem at hand. When used with "classical" programming languages this notion of a subscriber is somewhat misleading. Its more often implemented as a notification system where the observers gets notified and only then decides if they want or need the update. Usually the observable maintain a list or so of pointers to the observers and run through this list calling the observers notify method. The observers then call the update method of the observable when and if needed.

"Classical" object-oriented programming languages provide constructs like interfaces, that acts as contracts guaranteeing that certain methods exist. Interfaces does not contain any code. Other often completely different classes implement the interface. This is how the observables can maintain a unified list of observers and at the same time let the observers implementation be heterogeneous.They don't need to extend the same class as long as they implement the methods described in the observer interface. 

Since JavaScript is a loosely typed programming language, meaning that it does not contain classes in the real sense and thereby do not differentiate between types of objects, it does not provide the programmer with interface like constructs.  

\begin{quotation}
“The thing about design patterns in relation to JavaScript is that, although language-independent, the design patterns were mostly studied from the perspective of strongly typed languages, such as C++ and Java. Sometimes it doesn’t necessarily make sense to apply them verbatim in a loosely typed dynamic language such as JavaScript. Sometimes these patterns are workarounds that deal with the strongly typed nature of the languages and the class-based inheritance. In JavaScript there might be simpler alternatives” \parencite[s. 2]{stefanov}.
\end{quotation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Methodology %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Methodology}
Why local testing has been crucial to developing the state application. Also to describe how I have moved forward developing the app.

\section{Behavior driven development}
Find source.

\subsection{Jasmine}
Using Jasmine as integration testing tool

\section{Modularity}
\subsection{Browserify, taking Nodejs NPM module loading technology to the browser}
Move to background?
Moved to discussion: \sout {Encapsulation}.
Modules
npm
browserify

\section{Subversion}

\section{Requirement specifications}
\begin{enumerate}
\item A basic / advanced mode should be able to be set from one button placed in the main navigation, from a small triangle on the border between the tools and the main iframe, with tabs within the main iframe when available and from within certain G suite tools. When setting mode in one place, the mode should be updated all the other relevant places.

\item Implement bookmarkable state.

\end{enumerate}

The first specification concern hiding information. The Hyperbrowser offers a vast amount of tools and every tool provide a lot of possible choices. From psychological experiments to web usability gurus such as Steve Kruge and Jakob Nielsen we have learned that to many choices makes us unhappy\parencite{schwartz2004paradox} \parencite{krug2005don} \parencite{nielsen1997user}. This well known web design / UX principle state that unexperienced users easily get confused when there is to much information to take in at on time.

The proposed solution to help new and unexperienced users is to present two "versions" of the site, a basic and an advanced mode. The advanced version will display the page as it is today, that is it will stay unchanged. The basic user mode will conceal the tool list and only present a guide to some basic tools. The guide is contained within the G suite and will not be a part of the specification for this thesis. The G suite also offer tools with the basic/ advanced distinction where tools presented in basic mode will have less choices than those in advanced mode. 
Relevant to this thesis is the integration of the G suite basic / advanced mode to the user interface of the Genomic Hyperbrowser. 

The second specification will deal with the fact that users expect certain behavior from a web site \parencite{mikowski} \parencite{nielsen1997user}. The current implementation of the Hyperbrowser does not adhere to the expected feature of bookmarking the state. 

The ability to save state will not only enable the researcher to come back and work with a research question at a later time, more importantly it promotes reproducibility. By letting researchers easily share their research questions and hypothesis the transparency of research can be increased. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Technical foundation %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Technical foundations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Development %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Results}
In this chapter I describe the result of the state investigations done on the specific case of the Genomic Hyperbrowser. The result is a working program that adds state management to a web site where such state does not exist originally. The intention is to add details relevant for the discussion and not be a thorough review of the whole code base.

I will start the chapter by describing the Graphical User Interface of the Genomic Hyperbrowser web site. This is done to give a better understanding of the use case under study and thereby build a foundation on which to better follow the discussion. 

Moved to discussion: \sout{I also try to reason why I have done as I have.}
\section{Describing the Hyperbrowser GUI}
\label{sec:hyperbrowserGUI}
The Hyperbrowser GUI consists of four distinct parts. The logo and main navigation bar is located on top of the browser window. The rest of the page is split in three vertically aligned sections. The left most section consists of a list of links to genome specific tools. The next section, the middle one, is the main section of the Hyperbrowser. The right-most section consists of history elements. This thesis does not interfere with the history section and will not be discussing this any further. Clicking on one of the tools in the tool links section opens the corresponding tool in the main section. 

A tool consists of a HTML form with several options to choose from and a button to send the form to the server. This button is often called execute or start analysis. The button is usually grayed out when the form is incorrect or not sufficiently filled out to be executed. When a tool is executed a confirmation notice is displayed in the main section of the site and a history element is added to the history section.

Some tools has a dual appearance. These tools are part of the GSuite project. They have both a basic and an advanced representation. Only one of these appearances are sent from the server depending on the mode of the web site at the time of requesting the tool. Changing the mode of the web site request the other representation of the tool.

The main section also displays the welcome page when opening the Hyperbrowser. The welcome page is one of several tabs in the main section. The two other tabs important to this thesis is the basic and the advanced tab. These tabs display guides to how to use the tools provided by the G suite. The basic tab leads the user through a simplified workflow while the advanced tab gives the user full control of the analysis workflow. In the rest of this thesis I will be calling the over described tabs the gSuite guides. Important to mention is that these tabs are not present when displaying a tool in the main frame.

%The hyperbrowser GUI is build using iframes to separate content. The main window object contains the main navigation bar. Underneath the navigation bar the rest of the content is distributed into three different iframes. The first iframe consists of a list of links to genome wide analysis tools. The next iframe contains the main portion of the site and the third iframe contains the history elements. When clicking an item in the tool list the tool, represented by a form, is displayed within the middle iframe. The form consists of several select options, check boxes, text fields and buttons. The last iframe displays all the results generated by the users of this particular browser instance on this computer.

\section{Describing the stateApp}
\subsection{The functionality}
The stateApp has two main tasks. The first is to make sure that all parts of the HyperBrowser is synchronized against a "modeState". There are two modes: a basic and an advanced mode. The second is to record the state of the Hyperbrowser, the "toolState".

\begin{enumerate}
\item{ModeState:}
 Mode is affecting tree parts of the page. Firstly, the left sidebar where the tool section is located. This should be closed when in basic mode and open when in advanced mode. 

Secondly the G suite tools have two different representations delivered from the server. The stateApp need to know if the tool returned from the server is in basic or advanced mode and synchronize the rest of the application accordingly.

Thirdly the gSuite guides should be synchronized with the current page mode. When mode is changed somewhere outside the gSuite guides the stateApp should display the tab corresponding to the mode. It should also toggle the mode on rest of the app when a user switches from one tab to the other. 

\item{ToolState:}
The stateApp should record the state of the HyperBrowser to enable the default behaviors of web browsers to work as expected. By storing state on the fragment identifier of the URI the stateApp can restore the application state. This enables correct behavior of the back and forward buttons. It also enables the user to save the state as a regular bookmark or send the URL of a specific tool selection to a colleague or other interested party.
\end{enumerate}

\subsection{The flow}
As is the case for all JavaScript programs run in a web browser environment the execution of the code has two distinct phases. The initialization phase and the event phase\parencite[p.317]{flanagan}.

\subsubsection{The initialization phase} 
The initialization process starts by creating a history object. Before starting this history object the stateApp starts what I have called the modeApp. The tasks of the modeApp is to create a modeModel, a modeView and a modeController. It then sets up mode related event listeners and returns.

After the modeApp has returned the toolApp is started. The toolApp creates a toolModel, a toolView and a toolController. As with the modeApp the toolApp now sets up event listeners related to record the state of the tools. Since the tools are basically HTML forms, the toolApp is set up to serialize the form and add the serialization to the toolModel. The form is serialized on every reload of the main frame. When the event listeners are all set up the program returns to the main initialization code.

On returning from the toolApp the history object is started. It first checks to see if the hash part of the windows location property is set. Unless the location hash is set the program continues on to consult the browsers local storage. If no state is stored on the local storage the program sets itself with the basic mode. If local storage has mode information the history object triggers a history:change event with the state stored on local storage attached to the event object. This is also the case if the location hash is set: the program triggers a history:change event with the parsed URI object attached instead of the state object from local storage. The triggering and the initialization process is terminated. This marks the start of the second phase of the program, the event phase.

\subsubsection{The event phase}
After the initialization has terminated the app enters the event phase. All the objects created in the initialization process has been extended with a common dispatcher object allowing internal communication within the objects of the app. This internal communication is not in any way connected with the browsers event mechanism even though they are similar.

The dispatcher object of the stateApp is designed as an observable and an observer in one object. By extending all the other objects with the dispatcher object, every object is made into observers observing the central dispatcher object. They still have to register to events to be "notified" when the events are triggered. The notification is put in quotes here because of the way the dispatcher is designed. JavaScripts offers functions to be passed around as objects. This way the dispatcher can receive the function to be triggered directly instead of the object within which the functionality would otherwise reside according to the Observer pattern. The event phase continue till the browser window is shut down. 

When in the event phase the program will have long periods of silence where no code is run. These long stretches of no activity will be interrupted by bursts of activity when a user interacts with the site or the browsers.


\subsection{Storing and retrieving state from the URI}
To store state on the URI the state must be transformed to a string. The process of transforming JavaScript objects to strings is often called a stringifying process. The process of transforming the URI back to a JavaScript object is called parsing. The third-party library UriAnchor provides utility methods for parsing and stringifying the part of the URI I will refer to as the fragment identifier. See section \ref{sec:URI} for a detailed discussion on the URI and the fragment identifier. 


\subsubsection{The uriAnchor library}
The main functionality of the UriAnchor library is to stringify complex 
objects onto the fragment identifier part of the location string and vice versa to parse the location string back to a javaScript object. For instances, in relation to storing the mode state in the stateApp, the mode state can be put in an object and given to the setAnchor method of the uriAnchor library:
\label{sec:results_uriAnchor}
\begin{lstlisting}[caption=Setting the location with the Uri Anchor library]
  uriAnchor.setAnchor({mode: 'basic'}); 
\end{lstlisting}


The uriAnchor will set the location.hash for you. This will be reflected in the address field of the browser like so: 
%[caption=My Javascript Example]
\begin{lstlisting}[caption=The browsers address field after using the setAnchor 
method of the uriAnchor library]
  "https://hyperbrowser.uio.no/state/#mode=basic"
\end{lstlisting}

If other state is needed to be recorded as well, the key/value pair will be separated with an ampersand (\&):

\begin{lstlisting}[caption=Standard key/value separation of the URI parameters]
  #mode=basic&otherState=testState
\end{lstlisting}

The library also supports storing state objects within objects. It does this by associating an independent property of the state object with a dependent property. The dependent property holds the additional associated state for the independent state property:

\begin{lstlisting}[caption=The UriAnchor library. Parsed complex object.]
  $.uriAnchor.setAnchor({
  mode  : 'advanced',
  tool  : 'Analyze genomic tracks',
  _tool : {
   serializedForm   : 'dbkey=blackrust',
   currentSelection : 'galaxy_main'
  },
  otherFutureProperties : 'red'
});
\end{lstlisting}

In listing 4.4 the "mode" and "tool" properties are what has been called named, independent properties. They are named in that they have strings as values and they do not depend on any other properties. The "\_tool" property on the other hand does not have an independent string value. The value is an object and the properties of that object are associated with the "tool" object through convention. The "\_tool" property has been called the dependent variable as it represents additional properties of the associated independent property. 

\begin{lstlisting}[caption=Example of a stringified complex object.]
#mode=advanced&tool=Analyze%20genomic%20tracks:serializedForm,dbkey%3Dblackrust
\end{lstlisting}



\subsubsection{Separating state change}
Changing the URI trigger a browser hashchange event. This event is caught by the history object. One of the many task of the history object is to trigger separate events for each state that is changed. The uriAnchor library simplifies this process of separation. As the history object loops through the state object returned from the uriAnchors makeAnchorMap() method it triggers an event specific to each independent property. If there is a dependent object associated with the property at hand the history object passes this along with the event. 

\subsubsection{Make sure only changed state trigger events}
To make sure unnecessary events are triggered the history object checks against the local storage to see what properties actually has changed since the last saved state object. The state object returned from the makeAnchorMap offers for each dependent object a string representation of that object. This simplifies the check against previous state objects.

%the overall structure of the state app.
%pdf overview of object interaction/object diagram
\section{Design choices}
\subsection{Emulating certain features of Backbonejs}
\section{Building blocks / Objects}
\subsection{The modeApp and the toolApp}
\subsubsection{ModeApp}
The first responsibility of the modeApp is to create mode specific objects: the modeModel, the modeView and the modeController. It also adds the modeView to the main navigation bar. The mode view is the basic/ advanced button with its sub menu.

It also sets up the mode listeners. 

\subsubsection{The responsibilities of the ToolApp}
The toolApp has many of the same responsibilities as the modeApp. It creates tool specific objects and sets up tool specific listeners. For instance, to record a tool state the toolApp listens for the documents "ready" event. This document belongs to the middle iframe and should not be confused with the document associated with the main window of the site. After the browser has rendered a server response targeted for the middle iframe it emits a ready event which is caught by the toolApp object. 

On catching the "ready" event the toolApp records the tool state by finding the form of the iframes document and then serialize the form with the jQuery serialize method. The serialization is then set on the toolModel.

After setting the toolModel the toolApp is responsible for deciding if the tool is a GSuite tool and if so hide the "isBasic" check box. All GSuite tools is delivered with a "isBasic" check box for retrieving the other representation of the tool from the server. Remember all GSuite tool has a basic and an advanced representation of the tool. This is done by checking if the "isBasic" id is present. Only GSuite tools has an "isBasic" id within the document. 
\label{sec:gsuiteMode}
To account for situations where the current mode of the page is not coherent with a newly loaded tool representation the sites mode needs to be adjusted accordingly. Since this is only possible to know as the tool is done loading and the toolApp already has a "ready" listener, this responsibility is given to the toolApp. The check to decide if the tool mode is coherent with the mode of the site is done by checking the isBasic checkbox against the modeModel. This is why the toolApp needs to be injected with a modeModel upon initialization. 

The situation described over can occur when rerunning a tool from the history section of the site. The history objects for GSuite tools will be in the same mode as when the tool was originally run. If the mode of the Hyperbrowsers site has changed since running the tool, rerunning it will cause a mode discrepancy. The app is set to change the mode of the site such that it is coherent with the mode of the rerun tool. It could be argued that the tool should be sett according to the mode of the site. This is a discussion outside the scope of this thesis.

There are also scenarios where the tools mode state and the Hyperbrowsers state are equal when the "ready" state is emitted but the URI is out of sync. This is the last condition the toolApp is responsible to check before it returns.


The table \ref{table:1} is a visual representation of the mode state of the Model, the GSuite tool, and the URI after clicking the change mode button. The program algorithm for a mode change gos as follows:

\begin{enumerate}
\item The base case. Site is in basic mode. No code is being executed. The program is in listening modus.
\item A user clicks the basic/ advanced button.
\item ModeView catches the "click" event.
\item ModeModel is toggled to advanced mode.
\item ModeCTRL checks the "isBasic" checkbox on the GSuite tool.
\item Browser sets the location object of the iframe and requests the advanced representation of the tool from the server. A new item is added to the history list.
\item Browser loads the new tool representation and emits a "ready" event.
\item ToolApp sets toolModel when catching the "ready" event.
\item ToolModel is set and causes a history replace. The previous "stateless" entry is overridden by this "statefull" entry.
\item ToolApp continues and sets the modeModel with the GSuite flag to true and triggers another mode change. This time it sets the modeModel with the same mode it already has. The normal path of triggering the moving of the sidebar and checking the "isBasic" checkbox is this time derailed.
\item The mode change is now merged with the current location hash. Then history is replaced with this new state object. 
\end{enumerate}
 
\begin{table}
\centering
    \begin{tabular}{rlll}
    
     Step    & Model    & Tool     & URI      \\ [0.5ex]\hline\\ [0.1ex]
        1    & Basic    & Basic    & Basic    \\ 
        4    & Advanced & Basic    & Basic    \\ 
        7    & Advanced & Advanced & Basic    \\ 
        11    & Advanced & Advanced & Advanced \\[1ex] 

    \end{tabular}
    \caption{The state of different parts of the program while changing mode}
\label{table:1}
\end{table}

EXAMPLES OF USE?

\subsection{Prototypes}
\subsubsection{Model prototype}
\subsubsection{View prototype}
\subsubsection{Controller prototype}
\subsubsection{History prototype}

\subsection{Models, view and controllers} 

\subsubsection{GSuite mode}





\subsubsection{Dispatcher prototype}
At the core of the program lies two well known design patterns: "The Model View Controller" might better be described as an architecture than and design pattern as discussed in the previous chapter. "The Observer pattern" on the other hand is a fully fledged classical design pattern.

The dispatcher object in the state app is an example of an observable but implemented differently from the "classical" approach. The dispatcher will be discussed in due time. As for now it suffices to say that instead of maintaining a list of interface pointers to observers, the observers, when registering to the observable, leave a pointer directly to the function that needs to be called. When the dispatcher is prompted to trigger or dispatch an event it goes through the lists of functions and calls them directly without the need of a specific type interface. An attached context pointer is registered together with the function and it is this context pointer that represents the object the functions "this" keyword points to.

\paragraph{Naming conventions}
The Dispatcher prototype is inspired by the Observer pattern. It provides the methods for registering, for unregistering and for notifying as was originally proposed by Gamma et al. However, one of the main features of a pattern is the choice of name\parencite[p. 3]{gamma} so I will spend some time clarifying my motives for choosing the names I have. 

Since the state application is web based I have chosen to use a naming convention frequently used when dealing with events in web client applications. The state applications corresponding methods are listenTo, stopListening and triggerEvent. The names are borrowed from Backbonejs events object except for the trigger method which have been named triggerEvent. The reason for the latter is to avoid confusion with the jQuery object that already has a method called trigger.

The name of the object itself also differ from that of Backbonejs. To better convey the understanding of the object as a central unit for distributing actions to its listeners it has been called the Dispatcher. The notion of a dispatcher is also used in the browser implementations of the observer pattern, the dispatchEvent() method. 

The other corresponding methods in the browser are called addEventListener and removeEventListerner. The indication of adding something that the browsers naming introduces is somewhat lost with the listening name schema. 
%By calling this object the Dispatcher instead of the Event object I try to compensate for the lost meaning of adding something, which is what is actually done with the implementations both by the browsers and by the state applications as I will show in the following.

\paragraph{Loose coupling} Instead of registering with a pointer to an object such that the observable can iterate the list of object pointers and call their respective update methods, the observers leave with the observable the function to be called. The advantage of leaving a pointer to the function and letting the dispatcher call it directly is that of loose coupling.

The observable does not need to know about a specific method, like the update method in the original observer pattern. It can just call the function oblivious to who owns it and what it does. This is the first principle of loose coupling.

Since JavaScript is a loosely typed language and does not offer safety constructs ensuring that interfaces and the implementing classes maintains the contract of providing certain methods, implementing the suggestions by the observer pattern  

The dispatcher just calls some function with the attached context pointer and goes on being observable. 

I call this pointer to the listening object the "context". This is possible because functions in JavaScript are considered as objects and as any JavaScript objects functions can have methods.

The Function.prototype has three methods: bind, apply and call that can be used to make any function as if it was a method of any object. The dispatcher uses the latter to call the functions left to the observable. The call method of the function uses the "context" and thereby calls the function as a method of the context.

It is a utility object that all the models, views, controllers and the history object listens to. The events are then dispatched to all listening objects. 

Push vs pull.

The main purpose of the dispatcher is providing a system for communicating state change in the participating objects.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Discussion %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Discussion}

This discussion will follow three distinct paths as proposed in the claims section of the introduction. Just as a reminder; the goal is to get a clearer understanding of how to handle state in a context of an existing web page. The empirical foundation for the discussion is "The Genomic Hyperbrowser", the existing application, and "The state management application", the state handling program. In the remaining discussion I will refer to the former as just the Hyperbrowser and the latter as the StateApp.

\chapter{On applying state management}

"A simple task like implementing a basic/advanced button, distingushing between a basic and advanced part of a web site, applied client side on top of an existing server rendered web page is not trivial"

I will start the discussion with elaborating on the general challenges on developing client side applications before moving to specific problems relating the development of state management and the stateApp. It is important to understand the context of the development environment to get a tighter grip on the problems at hand.
%%%%%%%%%%%%%%%%%%%%%%%%% P1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Applied client side:
\section{The nature of web clients create hurdles}
The nature of web clients create some challenges of its own when developing client side applications. 

\subsection{The browsers implementation of javaScript and the DOM differ}
One of the challenges of writing nontrivial JavaScript client-side programs is to ensure they run correctly on the wide variety of different browser implementations we have to day\parencite[p. 325]{flanagan}. One example of the discrepancy between browser vendors JavaScript implementation is Microsofts reluctance to implement the DOM Level 2 Events specification which is The World Wide Web Consortium (W3C) recommended standard\parencite{w3c}. This specification includes crucial functionality such as the AddEventListener which is paramount to most interaction with a web page. 

To accommodate for these differences the programmer need to write a lot of extra boilerplate code if the use of natively supported JavaScript is important. What many chooses to do in stead, is to use an external, third-party library to query the DOM. 

\subsubsection{JQuery to the rescue}
With the plethora of JavaScript libraries available, jQuery is the most widely used according to the libscore search engine\parencite{infoWorld}. The ease of use and the great amount of functionality besides querying the DOM, most significantly their handling of Ajax calls has been the leading reasons why we have chosen jQuery over other libraries such as Motools and Dojo. 

\subsubsection{The browser implementations of javaScript is not a big problem with modern browsers}
Since the release of Internet Explorer 9, however, Microsoft finally decided to implement the decade old W3C standardizations and as a result most of the browser differences disappeared. 

One might think that this would be the end of the widespread use of JavaScript libraries but that has not been the case. A quick google search on jQuery usage statistics showed that between 60 and 70\% of the top 10k web sites still rely on jQuery \parencite{jQueryWiki} \parencite{jQueryW3Tech}\parencite{builtWith}. 

Even though most of the implementation differences has disappeared there still exist discrepancies between the browsers as we shall see in the section \ref{sec:backButton} 

\subsubsection{The need to support legacy browsers}
A natural explanation for the continuing popularity of jQuery is the need for many web sites to provide satisfactory service to legacy browsers such as Microsofts Internet Explorer 8 and before. This also applies when developing new functionality to the HyperBrowser. The goal of being a service available to the public leaves no choice but to cater for the communities where replacing the computer for every third release of new software is unaffordable. 



\subsubsection{New features still have different implementations in different browsers}
The vast amount of mobile and tablet browsers running on different software but also regular browsers for desktop computers does not implement new features consistently or at the same time. New HTML5 technologies such as Server-sent events and the file API are still not implemented by the newest Microsoft layout engine, the EdgeHTML\parencite{comparison_of_layout_engines}. Since the mentioned technologies does not affect the implementation of the stateApp, this is not a problem and will be left as it is.

%NB!!! This must be discussed further later since it is not answered for here. Jquery does not remedy this problem.
An other crucial functionality that is implemented differently in a wide variety of browsers is the browsers caching strategies in relation to retrieving bookmarks, back and forward buttons. Do they restore pages from cache or do they reload the page from the server? This problem is not remedied by jQuery or any of the other JavaScript frameworks. Related to the same issue is the difference in implementation of the location assign and location reload functionality. These problems are fundamental to state management and will be brought back to the discussion as it closes in on the difficulties experienced with the concrete implementation of the stateApp. 
%All the browsers behave differently when going back on the Hyperbrowser.

\subsection{The Uniform Resource Identifier, a source to headaches}
\label{sec:URI}
\subsubsection{The distinction between a URI and a URL is confusing}
%To formal and hard to read. Needs a short and easy intro to the issues
The URI scheme is meant to be a way of uniquely identifying representations of resources in a network. The URI is a string of characters, formed in a well defined manner, specifying the rules for obtaining a resource. A URI can be classified as a locator specifying the access mechanism of a resource. When used as a locator it is called a Uniform Resource Locator (URL). It can also be classified as a name representing globally unique resources. When used as a name it is called a Unifrom Recourse Name (URN). Combining the two can also be classified as a valid URI\parencite{rfc_URI}.

The partitioning of URI space into URL's and URN's have caused some confusion in the web community\parencite{w3c_URI}. Both URL's and URN's are subsets of URI's. For simplicity one can say that a URL is used to identify the location of a resource in time. The URN is the unique name independent of the location of the resource and its primary purpose is to maintain a persistent labeling of a resources also when the resource no longer exists or becomes unavailable. 

Both URL's and URN's need to conform to strict rules to be valid URI's. The hyperbrowser does not define named resources (URN) in any way compliant with the rules of the generic syntax specification for URI's, hence I will not be discussing URN's any further. I will mainly concentrate the discussion on the location of a resource, the URL, but since a URI still identify a resource I will continue using the URI terminology. 

\subsubsection{The syntactic rules of a URI are overwhelming}
The paper defining the syntax of the URI, the "URI Generic Syntax" (RFC2396), encompass 40 pages of detailed descriptions, jet is only a superset of all the URI schemes available. Examples of URI schemes are ftp, http and mailto. All have their own specifications and are often to much to consider in detail for a web developer. 

It should be mentioned for the record that even though many of these schemes have the names of protocols that does not imply they are the same as the protocol they are named after. It neither imply that access to the URL's recourse is only possible using that protocol. Oftentimes it requires two protocols to reach a document. When accessing the resource of a http scheme it requires both the HTTP and the DNS protocol\parencite{rfc_URI}.

Since defining most of the URI schemes of the web is already done and the deciding on naming hierarchies for resources is done by those developing the server, URI grammar is not relevant for the front-end developer. The front-end developer only needs to use the predefined schemes when requesting resources. 

However true this might be on a strict level, this argument might not apply equally well when considering the state of an application. Specifically when utilizing the HTML5 specifications of the History API or the fragment identifier for storing state, the rules of the URI schemes might be of some importance. For instance the use of the forward slash character "/", the fragment identifier or hash "\#", and the colon ":"" are all restricted characters with special meaning when used in a URI.The forward slash divides actors in a hierarchical relationship, the hash has traditionally been used to index certain parts of a document and the third character plays a central part when I discuss a third party library in relation to state management. 

Servers do not interpret the fragment identifier part of the URI string and has therefor also been used as a place to store state specific information used by the client program. Strictly speaking the fragment identifier is not an official part of a URI, but its use in conjunction with the URI and the important role it plays when handling state on a client should be enough to defend the space I have set aside to discussing the issues of the URI.

The URI considerations relevant to the development of an existing web page will be elaborated in the coming sections, where I discuss the concrete problems of using the fragment identifier to store state on the "Genomic Hyperbrowser". 

%%%%%%%%%%%%%%%%%%%%%%%%% P2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Existing page: Combining P2 and P3 to Adding state management on an existing page is challenging?
\section{Extending an existing program is not straight forward}
In this section I will discuss the challenges of applying state management on an existing web page. More specifically I will discuss the concrete challenges I encountered when trying to apply state management on the specific case of the "Genomic Hyperbrowser". I will in the rest of the thesis call the new state management on the Genomic Hyperbrowser for the "stateApp".

I will pick up the thread from the previous section by giving an account of why the URI has been considered a natural place for state associations.

\subsection{Storing state on the URI fragment identifier (\#)}
The state within a web page, as explained in background chapter(\ref{sec:state}), must be stored on the client for the state to be accounted for when implementing the user expected behavior of a web page, i.e. the back and forward buttons of the browser and the browsers ability to bookmark. The question is where the state should be stored on the client. Before I elaborate on this question I will give a quick account of the browsers default history management.%There are several options. 

%NB!! Define what is meant by a web page opposed to web pages
%\subsubsection{Using the URI as state storage}
% State is explained elsewhere
% The expected browser behavior is also explained elsewhere. Combine the two.
\subsubsection{The history object of the window element}
In the early days of the World Wide browsers displayed web pages containing static information with the possibility to link to other web pages. When clicking or otherwise navigating to an other page the browser added the URL of the new page onto the end of a history object. This history object was a property of the window element and contained some kind of data structure, for instance a list, on which the visited URI's were stored. When using the browsers back button the history list lets the window location property point to the previously added item. In this way the browsers enabled the user to navigate back and forward in the history lits. This was straight forward and easy to understand for most web users.

The browsers also offered a way to link to a certain area of a web page. The fragment identifier was originally used for this purpose. Any element given an id attribute could be linked to with the fragment identifier. On the src attribute of an anchor element, which usually is used for placing URI's leading to other pages, adding a "\#" and the id of the element, the document would scroll leaving the element in question at the top of the window.

Fig.

\subsubsection{The web 2.0 revolution and the need for an extra layer of identification}
When the web evolved beyond that of only being able to display static information, the web 2.0 revolution, changing only parts of a page soon became the new norm. By utilizing the new XMLHttpRequest object, the client could, asynchronously, request data from a server adding information on to an already open page. This way a single web page with one URI could be displayed with completely different data. The different data in time is what I call state.

\label{sec:storingState}
This new way of displaying dynamic information resulted in a need for an extra layer of identification. Since parts of the URI, the web address, already was used to identify a collection of resources for a certain web site, the fragment identifier seemed like a natural place to associate state specific information. The server do not interpret that part of the URI so the client-side developer is free to use it as she may see fit. 

Kannan et al. proposes to use the fragment identifier as a place to put page coordinates. This enables browsers to focus on certain parts of a static display of information, thus making the Internet more dynamic\parencite{Kannan:2006:LUB:1135777.1135924}. Others has use the fragment identifier as a means to apply logical names for specific parts of a document allowing for automatic generation of web pages\parencite{Aimar199599}. This can for instance be used by semantic technologies. 

\subsubsection{The promises of history management in the browsers address field}
\label{sec:uriAnchor}
Using the fragment identifier as a place to store state has also been proposed by Mikowski et al.\parencite{mikowski}. In connection with their book "Single page web applications" they have developed a jQuery library, the URI anchor. The library authors state that the library will help you: "Make your application bookmarks, browser history, the back button, and the forward button act just as the user expects while enabling you to update only the part of the page that has changed."\parencite{urianchor}. The functionality of the uriAnchor is described in the results section (\ref{sec:results_uriAnchor}). 


\paragraph{To depend on the UriAnchor library} which add functionality already provided by other parts of the program might seem redundant. It leads to more complex code by adding extra variables to keep track of and it will also add to the download cost as it add to the amount of code needed to run the program on the client. For instance using the jQuery param method in combination with the default JavaScript encodeUriCompontent will cater for the stringification process. The only problem is that jQuery does not offer a method to parse a URI to an object. 

JSON is an alternative with JSON.parse. Elaborate.

There exists other less official code on the World Wide Web that provides this functionality but this code is usually not maintained and might cause problems in the future. 

A more significant reason for using the UriAnhor library is that it provide the possibility to handle complex objects. By complex I here mean that the named properties of the object to be stringified can have dependent variables associated with them. These dependent variables will be encoded on the fragment part of the URI along with all the independent variables. 

This is a good fit for the StateApp. It provides the ability to parse and stringify a state object. The mode state only needs a string representation whereas the tool state need more complex data structures representing it. 

A natural question to ask here is why couldn't the value of the independent variable just be a regular object and the string value associated with the independent variable be stored alongside the other dependent variables inside the value object like listing 5.6?

\begin{lstlisting}[caption=Example of a stringified complex object.]
 $.uriAnchor.setAnchor({
   mode  : 'advanced',
   tool  : {
    toolName : 'Analyze genomic tracks',
    serializedForm   : 'dbkey=blackrust',
    currentSelection : 'galaxy_main'
   },
   otherFutureProperties : 'red'
 });
 \end{lstlisting}

The answer is that by introducing an explicit dependency relationship like the one explained above, the association between dependent and independent variables could be visible in the URI. As shown in listing 5.5 the relationship are indicated by a colon (:). Without the visible dependency relation, the colon, it would be hard to express the relationship in the URI. 

\paragraph{The decision to use the UriAnchor} as a means to stringify and encode state objects on to the address field of the browser turned out to be more troublesome than anticipated. In early stages of developing the stateApp there existed a need to retrieve a tool from the server initiated by the stateApp. This had to be done by sending a predefined property, GALAXY\_URL, attached to the search part of the URI. The value of this property should contain the full URI:

\begin{lstlisting}[caption= The full URI to retrieve a hyperbrowser tool.]
https://hyperbrowser.uio.no/state/hyper?GALAXY_URL=https%3A//hyperbrowser.uio.no/state/tool_runner&tool_id=hb_test_1
\end{lstlisting}

It turns out that the UriAnchor library decodes the URI before parsing it. This is problematic in relation to URI syntactics. The URI grammar restricts the use of the colon (:) as it is used to separate the protocol scheme from the rest of the URI. Two examples are http: and ftp:. Because the UriAnchor decodes the URI before parsing it and by that expose any percent-encoded characters, the colon indicating the relationship between dependent and independent variable breaks any web addresses stringified in the URI. 

\paragraph{Percent-encoding} enables the use of restricted characters in a URI. This is also called URL encoding. The percent sign is used as an escape character followed by a pair of hexadecimal digits representing the characters ASCII byte value\parencite{urlencode}. The colon is thus encoded \%3A as seen in listing 5.5.

When the UriAnchor parser meets the search part of the URI where the tool address is stored in the GALAXY\_URL parameter it takes the colon in https:// to be an indicator of the dependency relationship and thus breaks the address.

To remedy this problem the default dependent/ independent relationship indicator, the colon, can be changed. Strangely enough the UriAnchor library provides the possibility to change the default delimiters but the code that does this is disabled.The documentation outlines the default delimiters and explains how to replace them but does not mention that they are disabled and thereby does not work. To enable replacing delimiters one needs to read and understand the whole code base of the library. It became a challenging hunt for fixing the bug. I chose to use a dash followed by a greater than sign "->" to indicate the dependency relationship.   

%Follow up on the subsubsection heading prospecting history management.
\paragraph{Adding state to the URI does not solve history management by it self.} 
Remember the reason for storing state on the fragment identifier is to be able to restore that state and display that stored state to the user whenever a bookmark is called for or the back or forward buttons of the browser is clicked. As explained earlier this functionality is there by default when there is no state to store on the fragment part of the URI. The default behavior of the browser then adds every request coming from the server on to the list of history items. Parsing the state stored on the fragment identifier of the URI must be done by the client side program.This is not a trivial task and will be discussed in the following section.

\subsection{Hijacking functionality or passively recording state?}
When applying state management on an existing page one need to consider the pros and cons of hijacking existing functionality contra merely record the states passively as they emerge. This consideration needs to be investigated because of the way the browsers native history management works. Interfering with existing server communication can be a solution to the problem of double history entries when managing state. We start of by introducing the problem: 

When a user clicks a link on a web page the default browser behavior is to add the URI of the link to the location object, the browsers address field, and record an entry to the history object before requesting that page from the server. As the response returns the browsers caching engine stores the received data and sends the response to the browsers rendering engine who displays the page on screen. This is straight forward for static pages.

Introducing client side states, like a basic and advanced mode, can make things more complicated. As proposed in the previous section such states can be stored on the fragment identifier and as they are, an additional history item is added to the history object. This means that for every new type of state to be recorded there will be an additional history item added. To navigate to the previous site one now need to click the back button twice. This might not seem like a big problem but is nevertheless an unexpected behavior that might confuse the user. 

%The goal for every web developer must be to confuse or irritate the user as little as possible.

An example of this happens when opening the Hyperbrowser for the first time. The browser loads the page and adds a history item. Then the stateApp consult the localStorage and sets the state stored there or if no state is stored initializes the application with the basic mode. 

\subsubsection{Hijacking functionality}
To be in full control of when the browser adds an item to the history object it will be necessary to interfere with the existing server communication. This includes preventing the default behavior of the web browser. Again, for a static page this wouldn't be much of a problem. An example of overriding the default behavior of the browser is to control the behavior of a link. After preventing the default behavior one could get hold of the value of the links source attribute, append the fragment identifier on to that and then add the state. After building the URI this way one could set the location with this new URI and thereby setting the history only once. 

Hijacking the default behavior like this might not be as straight forward with an existing application. For instance when doing a selection in one of the HyperBrowser tools there is a lot of complex assessments, server communication and validation going on. To interfere with this kind of code the front end-developer should be familiar with the inner workings and expectations of the server. To tamper with it could lead to unknown behavior and unimaginable consequences. When dealing with complex functionality like this it might be better to let the existing code do its thing and focus on recording the state passively as it emerges.

The most important objection of hijacking the existing functionality in the case of the Hyperbrowser is that the state of the tool can not be anticipated until the tool is received from the server and rendered readable on to the DOM. Only when the tool is present in the DOM the tool state can be recorded and added to the fragment identifier.

\subsubsection{Passively record state}
Instead of overriding the existing handling of server communication one can record the different states as they are set. For instance, every time a user does a selection or otherwise alter a tool form on the Hyperbrowser site, the server is consulted and a new state of the tool form is sent from the server. When the browser is done rendering the DOM it fires the documents "ready" event. The stateApp can then serialize the form and save the resulting string to the URI. This means that for every state change the server first adds a history object, then requests the new tool state from the server, renders the new tool state and then fires the documents "ready" event. The stateApp adds this new state to the URI and the browser adds another history item, resulting in the need to click the back button twice to get back to the previous state. 

\subsubsection{Avoid server communication}
Taken these considerations into account the stateApp tries not to interfere with the existing server communication or the server at all. There is only one exception. When restoring state from the URI, for instance when a user opens a bookmark, the stateApp requests the server for a tool. This is done using jQuerys ajax method, passing the serializedForm part of the URI to the server. This caused some problems and will be discussed later when dealing with the problems of frames (\ref{sec:iframes}. NB! Remember to discuss later.

\subsection{Conceal the double history entry by replacing the URI}
The obvious solution to the problem of setting the history object twice is to use the replace method of the location object. This is a method present on the location object by default in most browsers. When setting the location, instead of adding a new history item on top of the existing history entries it deletes the previous entry before adding the new. This works fine for the scenario described in the previous section.  

It does not render an adequate solution when opening a new tool from the tool menu. This literary adds to the problem by adding an extra event. Because the name of a tool is not present in the serialization of a tool form, the tool name must be recorded when clicking the tool link in the tool menu section. The scenario goes as follows: The user clicks a tool, either in the tool menu section or from the GSuite guides. This is recorded by the toolModel and then added to the URI and a history entry is recorded by the browser. At the same time a request is sent to the server and an other history item is added to the history object. The server responds with a tool in its initial state and as the browser finishes rendering the DOM the stateApp records the tool state and adds it to the URI causing yet an other entry being added to the history object. This results in three history items being added when opening a tool. 

A simple replace will not work here. Even though the last two history items follow the same pattern as described over, the first recording, that of the tool name does not. This entry will replace the previous history item and thereby removing the previous state. That ruins the intentions of the back button. 

The solution suggested by the stateApp is to add the name of the tool on the toolModel, but stop the name from being added to the URI. When the tool state is set after the browser has rendered the new tool representation received from the server, the tool name is already recorded on the toolModel and is thereby added to the URI with the rest of the tool state. Following the pattern described over this last history entry will replace the entry made by the browser when the server was requested for the state change. 

This is a good example of the benefits of having a central model on which to store state instead of depending on the fragment identifier as a state storage location. When depending on the fragment identifier for state storage every time state needs to be stored a history item is added to the history object. This is not something the programmer can control. Having a state model that does not influence the history object gives the developer more freedom. 

%Point

There are also disadvantages of depending on a central model. Both state changes coming from user input and from "hashchange" events needs to be registered on the central model. User activity also needs to be added to the URI whereas changes to the URI should not float back up. How this question can be solved will be discussed in section \ref{sec:modelVSuri} 


\subsubsection{Mode state changes can not replace the previous history entry}
The pattern described over only works because the browser adds an extra history entry when the server is requested for state change. This entry is an empty entry when it comes to state. It is not visible in the main URI, that is the address field displayed on the top of the browser window. This is because this URI belongs to the main window. The empty entry is set on the location object of an iframe and is thus not visible to the user. More on iframe issues in section \ref{sec:iframes}. Replacing this entry restores the expected back button behavior when a tool updates its state, but does not do so when mode is set. 

Mode only sets one history entry. Replacing the previous entry on the history object deletes the previous history and thereby destroy the expected back button behavior. One solution to the problem is to add a conditional statement deciding whether the entry comes from a mode change or a tool state change. If mode should be set use the assign method of the location object, otherwise use the replace method. 

One way to discern whether the change is a mode change or a tool state change is to name the models. This is the solution used by the stateApp but introduces the problem of tight coupling between objects. Remember how all state change go through a model object before the specific state event is emitted. Naming the models for identification in other objects forces the receiving object to hard code the model names. This is not an ideal solution but the discussion belongs to the chapter of programming patterns (\ref{sec:patterns}) and will be continued there. 

\subsubsection{The dual mode of the GSuite tools introduces an extra history entry}
Because the tools contained in the GSuite project has different representations for the two modes, one basic and one advanced representation, they can not follow the same conditions as other mode changes. When a GSuite tool is open and the mode of the web site is toggled the server needs to be requested for the opposite representation of the tool. This results in the same flow as for a regular tool state change except that the mode is also set. This means that for every mode change on a GSuite tool tree history entries are set. First the mode causes a history entry, then the server causes another and then when the new tool state is set on the fragment identifier this causes a third history entry. 

For the stateApp we have chosen a solution where setting the mode state is delayed till after the tool state has replaced the history entry caused by the request for a new tool representation. The mode model is marked, adding a property with the name GSuite, and added to the replace condition when setting the URI. For implementation details see the results chapter (\ref{sec:gsuiteMode}).

The challenges concerning iframes will be discussed in section \ref{sec:iframes}


\subsection{How should a back button behave anyway? (The back button should lead the user back to the GSuite guides)} Elaborate
\label{sec:backButton}
How should a back button behave? Should it display the previous tool state or go back to the GSuite guides? Nielsen? proposes to go back to the last perceived state. What is perceived is hard to establish without any user testing but my intuition says that the last perceived state is going back to the GSuite guides. This is because of the relative easiness of changing a selection or other form element. There is no need to move the cursor all the way up to the back button to go back, when it is as easy or even easier to undo the selection. 

%http://www.zuschlogin.com/?p=41
To account for the problems of undoing small changes and going back to the previous content introducing a stepwise and going all the way back buttons like on a cd player could do the trick.
%Why would one want to bookmark? To be able to share the research questions.
%What is it the library does to provide back, forward and bookmark functionality? In a custom app vs in an existing environment.  




%instances of web pages pointing to the same resources. i.e. the HyperBrowser instances, state and dev2.

%\subsection{Storing state on localStorage}

%\subsection{Using the model in an MVC architecture for storing state}
%Bring to the table and elaborate in the design pattern section.

\subsection{Using iframes as a means to separate content is troublesome}
\label{sec:iframes}
\subsubsection{What is an iframe}
The HTML inline frame element or iframe is a special kind of HTML element. It allows for embedding a whole HTML page within this one element. This means the iframe will be a unique window with its own document object model (DOM) and its own unique unified resource identifier (URI). It will have a separate head and body element and all the properties of the window element will be unique and separate from the containing window element. This implicates several challenges for the developer. 

Before going into these challenges it is important to remove any misconception regarding the use of iframes. Many people believe that iframes are bad. This might stem from the fact that the World Wide Web Consortiums (W3C) decided to remove the frame and frameset elements from their recommendations. The reason these items are now obsolete in browsers is that they represented an other document model which was not ideal for a lot of reasons. These reasons are the same reasons the iframe should not be used to separate content and will be discussed shortly.

\subsubsection{Iframes are useful}
Iframes are not all bad. The loading of content from different servers can be useful in many different contexts. For instance embedding video from third-party providers such as youtube or Vimeo, a Google map or a facebook feed in an iframe can enhance a web page. The iframe provides an easy way to create mashups of highly useful content and it is as easy as copy and pasting code. The code needed is often made available by the content providers. 

In many cases using an iframe for displaying external content is not necessary. Content providers often offer data in other formats that do not require iframes. Formats like XML and JSON are popular and can be collected with ajax or comet technologies such as the HTML5 api Server-sent events. These technologies gives more control of the content for the developer but requires a lot more work.

An other benefit of loading third-party content using iframes is that it enables providers to apply fixes and future updates to the content without the local developer needing to know. This way users of content don't need to worry about compatibility issues when new technologies break current standards.

Allowing third-party programs on to a site could however be a security risk. Programs running in an iframe can steal information from the containing site, but because of the strict rules of the Same-Origin policy in browsers and the sandboxing attribute of iframes such risks are minimal. These problems often occur because iframe users have eased the restrictions of the iframe and thereby allowed the third-party scripts to do their attacks. 

Iframes can also be used to seamlessly add authentication with OAuth services and it can be used as a means to save state. The latter technique was often used for storing state with legacy browsers before the HTML5 history api. This technique is unfortunately not sufficient to enable bookmarkable state and sharing of URIs and is therefor not elaborated any further. 

Gmail is an example of a big site that uses iframes extensively. On a regular gmail account Gmail uses 11 iframes, non of which are used to separate content.


%\paragraph{Lower SEO ranking with iframes}
%Cloaking
%Not necessarily bad for SEO ranking.

%Same content as other sites will cause your page not to be indexed.

%\subsubsection{Every iframe is a separate window, with its separate DOM tree}
\subsubsection{Every web resource should be reachable without ambiguity from any other web resource}
\begin{quotation}
\noindent "Given that social filtering is one of the most powerful mechanisms for information discovery on the Internet, it is an utter disaster to disable the URL as an addressing mechanism."\parencite{nielsenFrames}
\end{quotation}
Designing a web site using iframes to separate content brakes with one of the fundamental ideas behind the World Wide Web; every web resource should have a unique identifier such that it can be reached, without ambiguity, from any other document\parencite{wwwArchitectureW3C}. When resources have unique URI's they can form the basis of a stable and lasting web that facilitates the sharing of knowledge and ideas. An iframe represents a separate resource from its containing window. It has a separate URI possibly with its own separate state encoded on its fragment identifier. An accurate representation of the containing windows state must be merged from all the states of the iframes it contains to be reached unambiguously. There exists no such merging mechanism by default in browsers. 

A scenario pictured from the world of bio medical informatics might give a clearer understanding of what can be lost when a web site does not handle frame state: A researcher creates a hypothesis using the Hyperbrowser as it was before the stateApp. She wants to share her hypothesis in an online article and copies the URI of the Hyperbrowser and paste the URI into her article. When later researchers want to replicate her findings they follow the link from the article but the link leads them to the welcome page of the site. The hypothesis will be lost forever.

The state of the hypothesis is lost because the Hyperbrowser GUI was build using iframes without considering to collect the state of the contained frames. The browser has no means to recreate the state from a URI if there is no state encoded on it. 

This way of using several iframes to separate content mimics the obsolete HTML frameset element. The frameset element allowed for frames to divide content into sections thereby enabling scrolling and loading of content in one frame without affecting the other sections. This was a welcomed feature for web designers before the advent of Ajax technologies. Now the same effect is better handled with CSS and Ajax. 

At the same time state still needs to be collected, stored, and saved somewhere when using ajax as a means to collect new data for a dynamic page. As is the case with iframes saving ajax collected state is not an automated feature of the browsers either. To be able to share information that information somehow needs to be encoded into a unit that is shareable. For the web this shareable unit has been the URI. By adding frame state to the fragment identifier the uniqueness of the page as an atomic unit of information is preserved. According to Jacob Nielse this was part of Tim Bernes-Lee's genius idea for the World Wide Web\parencite{nielsenFrames}. 


\subsection{Iframes represent separate browsing contexts}
The problems described over relates to all uses of iframes as content separators. The next section will describe concrete problems encountered developing the stateApp.

\subsubsection{No restriction on communication between iframes}
The protocol, host and port portions of a URI defines the origin of a document\parencite{flanagan}. Since every iframe has its own URI it also has its own window object and its own DOM and it might have a different origin than the containing window. This means that iframes might be subjects to the "Same-Origin Policy". The Same-Origin Policy is a security measure to prevent third-party malicious code to steal information from or manipulate other parts of a program. Since all the iframes contained on the Hyperbrowser site has the same origin these restrictions does not apply to the Hyperbrowser. 

Having said that, the fact that the iframes can contain their own scripts have consequences for the management of state in the case of the Hyperbrowser.

\paragraph{Ajax calls from outside the document of the iframe} create problems. Every time a selection is done within a Hyperbrowser tool a new document is requested from the server. The received document contain all HTML markup for the tool along with several JavaScript functions. The markup consist mostly of a form element and all the select options contained within that tool. The JavaScript functions are global function that are added to the window object of the iframe the document is targeted for. These functions do a lot of server communication, for instance validating if the selections form valid hypothesis or otherwise are possible to evaluate. The communication with the server is done using the jQuery ajax method. The ajax method needs a location to address the request and provides the URL property for this. When the URL property of the ajax method has been provided with only a relative URL, as is the case for the tool forms of the Hyperbrowser, the URL property uses the base URL relative to the document on which the code is present. Every document returned from the server this way has gotten the name "hyper" which renders the base url "http://hyperbrowser.uio.no/path/hyper". 

This works well when the code is called from within the document. When the code is received by other means, for instance after parsing the URI of a bookmark, the relative URL does not contain the name of the document. When parsing a URI coming from a bookmark, linked to from an external document or is pasted into the browsers address field the program parses the URI and at some point an ajax call is produced. In contrast to when HTML forms are submitted the ajax way of getting data from a server is not returned in the form of a named document. The information is returned in some other format, it could be XML, JSON or in this case, a regular string. This string is then written on to the correct iframes document. This iframe document has not gotten a name. The relative URL of this document will be "http://hyperbrowser.uio.no/path/". Since the document has no name the name section of the URI will be omitted. This brakes all the tool functionality.

The solution has been to add the "hyper" name to all the ajax calls in the received string. This is a hack and will brake if the name of the document is changed. 


\subsubsection{Loading}
A minor challenge when dealing with iframes is the fact that the elements of the iframe DOM is not ready until the "ready" event is emited on the window object of the iframe. This means that any listeners must wait for the "ready" event before they can be attached to the elements. This also relate to functionality present on an iframes document. It is therefor not possible to depend fully on functionality being present all the time.

For a developer not familiar with browsers loading issues this kind of thinking will be challenging. On the other side, with a little bit of planning and confidence in the event model for communication between objects one can label these kinds of challenges as trivial. 

There has, however, been an issue with functionality not present. Some of the Hyperbrowser navigation reloads versions of the page without the stateApp code present in the DOM. This means that all state management functionality is lost. For instance when navigating to the "Shared data" section of the site it was not possible to handle state or bookmark state. The mode button did not work. When navigating back to the "Analyze data" section of the page, where the state management were active, the whole page was reloaded resulting in a restart of the program. 

To avoid user frustration the mode button on the main navigation bar had to be removed when navigation to any of the "Shared data" pages.

%Different global object, and can be considered a different program when coming from different servers.

%In this case this is a solvable problem since the code for the different iframes reside on the same server. Same-Origin Policy. Also different ports and different protocol ie. http vs https. Not the script in it self, but the document from which the script is embedded.



%Asynchronisity? 

%Cross-site Scripting is taken care of by the fact that everything that is sent to the server is done by the functionality of the original page. Exception is the ajax call when loading a bookmark. This is actually not taken care of as of now. It is taken care of by the server hopefully. This should be checke out!!!


\paragraph{Do not relay on previously available functionality.} Create the functionality from scratch.

Recreating all functionality does not adhere to the open/closed principal (Robert Martin).

Time consuming.

But it enables creation of better code. No need to hack the code like my solution when redesigning.

\subsubsection{Not possible to print pages that uses iframes for content separation}
The last point to this section is that the print functionality of the browser has trouble printing pages that are made up of iframes. Inspecting a printout of the Hyperbrowser in figur \ref{fig:printEx} shows that the browser print each frame on top of each other leaving the page unintelligible. This is an obvious drawback of using iframes to separate content but can easily be remedied by providing an extra styles file, print.css, to the index.html file. 

\begin{figure}
\centering
\includegraphics[width=12cm]{printEx}
\caption{An example of a printout from a browser using iframes to separate content}
\label{fig:printEx}
\end{figure}

%\subusbsection{Iframes are not supported by screen readers}
\subsection{The HTML5 History api and pushState is not an alternative to using the fragment identifier to store state}
The HTML5 History api offers a way to store state in objects. A custom state object can be delivered directly to the history objects pushState or replaceState methods. Every time the back or forward button is clicked a "popstate" event is fired on the window object. There is only one problem, it does not enable bookmarking or sharing URI's. The history object is by the W3C called the "session history" implying that the history will not survive the session. As mentioned earlier the state of a page needs to be encoded in the URI to be shared. This renders the History Api unfitted for external state management.

In the specific case of the Hyperbrowser the History object and the push and replace state methods are also unusable because the server is not wired to accept any URI's other than those configured on the server.


%%%%%%%%%%%%%%%%%%%%%%%%% P4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Server rendered page:
%\section{The state needs to be captured and saved on the client}
%\subsection{Every state change generates a new page reload by the server}
%\subsection{The server does not maintain state over requests}
%\subsubsection{The server acts as if it was RESTfull, Every post request gives a unique response}

%%%%%%%%%%%%%%%%%%%%%%%%% C1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The server can be rewritten for handling state}
\subsection{Letting the server handle state, conflict with the idea of a RESTfull server in that it will not be stateless}
\subsection{This leads to slower server, etc, etc.}
\subsection{And is slower due to Speed of light}

%%%%%%%%%%%%%%%%%%%%%%%%% C2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Use a global boolean that all objects can relate to}
After the presentation of the State app implementation the first objection to this first sub thesis could go somewhere along the lines of: "But this should be easy, use a global variable that all other objects gets updated from." Since this, as for now, only is about the basic advanced distinction, there will only be one boolean to relate all other objects to. If they need to change, let them consult the global and ask for its state. If they need to set it, then synchronize that operation. Still easy.

Save the mode state in a global variable on the browsers localStorage makes for a simple program.

The window object?

Simple storage is a minimal fork of jstorage which is already used by the hyperbrowser.

Using plain window.localStorage excludes legacy browsers.

Varying capacity among browsers implementation of the localStorage and webStorage.

Elements in need of staying synchronized with the mode state will have no means to get updated when the mode changes.

The localStorage does not allow for emitting events when updated.

Saving state in the localStorage forces every element of the page that needs the mode state to constantly call the localStorage to get synchronized with the current state.

Processor expensive, not a good solution for mobile.
\subsection{The central unit of state}
\label{sec:modelVSuri} 
%Chapter 6. Where to store state, localStorage, URI or model?
\subsection{Solution to } 
Disable the basic/advanced app, and present a new button in place of the old one providing a link back to the state management app.

\chapter{On structuring complex code}
\label{sec:patterns}
"Structuring complex code using an unstructured, dynamic scripting language like java script can be challenging"
%%%%%%%%%%%%%%%%%%%%%%%%% C1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{C1: A plethora of frameworks to the rescue?}
Hard to integrate with existing design
\subsection{c1C1:Backbone to the rescue?}
The state app is based on some backbone principles. But the history object is hard to make compatible with the state app. 
\subsection{c1C1: Angular to the rescue?}
The pre-project. Learning and then tweaking not very easy.
\subsection{p1C1: UriAnchor makes the development easier?}
\subsubsection{c1p1C1: Bug when sending web address}
\subsubsection{p1p1C1: Simplifies dependent properties in the uri}
\subsubsection{c1p1C1: SetAnchor as a false prophet} 
SetAnchor reloads page, which must not be propagated back to the model. This has caused a lot of problems and has been time consuming. Because setting the location.hash by default does not trigger a hash change, but the SetAnchor does causes a triggering of a hashchange event, which caused me to doubt my self and my program. It made me create a lot of safety measures and unnecessary conditional code to account for the faulty triggering of the hash change. All this is not correct. The setAnchor did not set the location every time. The reason is that setting the location to the same url as it already is, does not trigger a hashchange. The solution was to set the triggerHashChange variable in the changeHistory as well as in the \_hashChange event handler.

%%%%%%%%%%%%%%%%%%%%%%%%% P1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{P1: Classical design patterns are misleading when used with JavaScript}
Keeping a model representation on the client, the M in MVC, is unnecessary when the URI can be used to convey state between states. The URI is needed to talk to the server anyway?  Pick up on the MVC controversy from the background.
\subsection{p1P1:Use the anchor as storage for state}
Claimed by UriAnchor author.

\subsubsection{c1p1P1: Using the location is not feasible with the Hyperbrowser}
Not possible because hash is emptied on every call to the server. Argument to an existing application?
\subsection{p1P1: Use LocalStorage as model?}

\subsubsection{c1p1P2: LocalStorage can not emit events}
P: When setting model state, how to inform other objects of the change?

\subsection{c1P1: Using the model as a driver of application state causes a bidirectional problem}

C: Current state is always available. Same if I had used LocalStorage.
%%%%%%%%%%%%%%%%%%%%%%%%% P2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{P2: Bad practice to pollute the global object with custom functionality}
\subsection{p1P2: Better to use closures and modules}
\subsubsection{Browserify is polluting the index.js file}
Have I overbrowserified my code?

Where should event listeners live? In the same objects that initialise other objects or in views, or even other specialised objects.

\chapter{On adding functionality to structured code}
"With structured code, new functionality comes easier"
\section{P1: Hooking the G-suite to the basic/advanced model was easy}
\section{C1: The need to differentiate what state type was changed, separate events triggered for separate models. Dependant properties of a model}
\section{C2: Encapsulation and loose coupling makes the code more complex}
Encapsulation and loose coupling between objects, ie the history object, makes the code more complex. If the history object listens for specific mode changes, the coupling tightens. If it listens to general model:change it needs to extract which model triggered the event change
\section{C3: Unnecessary generalisations make code more complex and harder to test}
ie differentiating between set and change events




% Moved from background. These sections has probably been handled already.
\subsection{State management in web clients}
\paragraph{Storing state in the browser}

\section{Anticipated behavior in a web application}
\section{Location hash or models as driving application state}

\section{Communicating with the DOM}

\section{Strictly objects vs class structures} (Discussion?)
\subsection{ECMA 5 vs ECMA 6} (Discussion?)

\section{Using third party libraries or design from scratch?} (Discussion?)

\subsection{Single page application on top of server heavy page - A hack?}
\subsection{Specific or broad approach}
\subsection{Using the native observer implementation from the new ECMA 6 Object}
\subsubsection{Code for the future ie pushState} 
\subsubsection{Both setHistory and changeHistory} 
 - More work. More mess.
 - Faster refactoring when new specifications
\subsubsection{uriAnchor vs. own development} 
\subsubsection{How to handle bugs in third party librarys?} 
\paragraph{Using framework or library vs creating from scratch}  
(Introduced in the background).
\paragraph{Local storage vs simple storage} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Conclusion %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}

\section{Thoughts on future development}



\newpage
% The headline of the bibliography (the document class article)
\renewcommand{\refname}{Bibliography}

% redefiner \bibname ved bruk av dokumentklassen book

% Litteraturlista inn i innholdsfortegnelsen
\addcontentsline{toc}{section}{\refname}

\printbibheading
\printbibliography[type=book, title={Books}]
\printbibliography[type=article, title={Articles}]
\printbibliography[type=inproceedings, title={In proceedings}]
\printbibliography[type=report, title={Technical reports}]
\printbibliography[nottype=book, nottype=article,%
nottype=report, nottype=inproceedings, title={Web resources}]

\end{document}

